from flask import Flask, render_template, request, session
import secrets
import sqlite3 as sql
from passlib.hash import sha256_crypt


app = Flask(__name__)
app.secret_key = secrets.token_hex(16)
host = 'http://127.0.0.1:5000/'


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        # Acquire user + pass from form
        username = request.form['UserName']
        password = request.form['Password']

        # Store role to determine priveledges
        role = request.form['role']
        # Used to remember current user across pages
        session['username'] = username
        session['role'] = role
        result = valid_login(username, password, role)
        # Need to check what type of role: Bidder, HelpDesk, or Seller
        if result:
            connection = sql.connect('database.db')
            # Get user information, as all are bidders
            cursor = connection.execute('SELECT * FROM Bidder WHERE email=?;', (username,))
            bidder = cursor.fetchone()
            connection.commit()
            # Sucessful login, go to home page
            return render_template('home.html', error=error, result=result, user=bidder, role=role)
        else:
            # Login failed
            error = 'Invalid login credentials. Please try again.'
    return render_template('login.html', error=error)


#Helper function to determine whether a login is valid
def valid_login(user_name, password_in, role):
    connection = sql.connect('database.db')
    #Checks to see if username + role combination is valid
    validRole = connection.execute('SELECT * FROM ' + role +' WHERE email=?;', (user_name,)).fetchone()
    if not validRole:
        isMatch = None
        return isMatch
    cursor = connection.execute('SELECT * FROM users WHERE username=?;', (user_name,))
    connection.commit()
    #Check if the hash of the password was generated by this hashing algorithm
    try:
        hashedPassword = cursor.fetchone()[1]
        isMatch = sha256_crypt.verify(password_in, hashedPassword)
    except:
        isMatch = None
    return isMatch


@app.route('/home', methods=['POST', 'GET'])
def home():
    user = session.get('username')
    # Request to switch roles
    if request.method == 'POST':
        role = request.form['role']

        connection = sql.connect('database.db')
        validRole = connection.execute('SELECT * FROM ' + role + ' WHERE email=?;', (user,)).fetchone()
        if not validRole:
            message = 'Error: you do not posses this role'
            role = session.get('role')
            cursor = connection.execute('SELECT * FROM Seller WHERE email=?;', (user,))
            isSeller = cursor.fetchone()
            # Checks if the current user is also a seller
            if isSeller:
                bankInfo = isSeller
            else:
                bankInfo = None
            isHelpDesk = connection.execute('SELECT * FROM helpdesk WHERE email=?;', (user,)).fetchone()
            # Checks if the current user is also a helpdesk user
            if isHelpDesk:
                position = isHelpDesk
            else:
                position = None
            # Pull user information, subsequently used to acquire address information and credit card digits
            cursor = connection.execute('SELECT * FROM Bidder WHERE email=?;', (user,))
            info = cursor.fetchone()
            address = connection.execute('SELECT * FROM Address WHERE address_id=?;', (info[5],)).fetchone()
            zip = connection.execute('SELECT * FROM Zipcode_Info WHERE zipcode=?;', (address[1],)).fetchone()
            credit = connection.execute('SELECT * FROM Credit_Cards WHERE Owner_email=?;', (user,)).fetchone()
            # Adjust the acquired string to just the final 4 digits of the credit card
            digits = credit[0][-4:]
            return render_template('account.html', info=info, address=address,
                                   zip=zip, bankInfo=bankInfo, digits=digits, role=role, position=position, message=message)
        # Fetch user information
        session['role'] = role
        cursor = connection.execute('SELECT * FROM Bidder WHERE email=?;', (user,))
        user = cursor.fetchone()
        return render_template('home.html', user=user, role=role)
    #Get user details from session

    role = session.get('role')
    connection = sql.connect('database.db')
    # Fetch user information
    cursor = connection.execute('SELECT * FROM Bidder WHERE email=?;', (user,))
    user = cursor.fetchone()
    return render_template('home.html', user=user, role=role)


@app.route('/account', methods=['POST', 'GET'])
def account():
    # Page for user account information, displays information based on type of user seller/bidder/heldesk
    user = session.get('username')
    role = session.get('role')
    connection = sql.connect('database.db')
    cursor = connection.execute('SELECT * FROM Seller WHERE email=?;', (user,))
    isSeller = cursor.fetchone()
    # Checks if the current user is also a seller
    if isSeller:
        bankInfo = isSeller
    else:
        bankInfo = None
    isHelpDesk = connection.execute('SELECT * FROM helpdesk WHERE email=?;', (user,)).fetchone()
    #Checks if the current user is also a helpdesk user
    if isHelpDesk:
        position = isHelpDesk
    else:
        position = None
    # Pull user information, subsequently used to acquire address information and credit card digits
    cursor = connection.execute('SELECT * FROM Bidder WHERE email=?;', (user,))
    info = cursor.fetchone()
    address = connection.execute('SELECT * FROM Address WHERE address_id=?;', (info[5],)).fetchone()
    zip = connection.execute('SELECT * FROM Zipcode_Info WHERE zipcode=?;', (address[1],)).fetchone()
    credit = connection.execute('SELECT * FROM Credit_Cards WHERE Owner_email=?;', (user,)).fetchone()
    # Adjust the acquired string to just the final 4 digits of the credit card
    digits = credit[0][-4:]
    return render_template('account.html', info=info, address=address,
                           zip=zip, bankInfo=bankInfo, digits=digits, role=role, position=position)

@app.route('/categories', methods=['POST', 'GET'])
def categories():
    # Display all the parent categories, allows the user to choose a parent categorie
    connection = sql.connect('database.db')
    #Fetch unique parent categories
    categories = connection.execute('SELECT DISTINCT parent_category FROM Categories ORDER BY parent_category').fetchall()
    #Removes unwanted characters from category
    items = [item[0] for item in categories]
    connection.close()
    return render_template('categories.html', items=items)

@app.route('/subcategory', methods=['POST', 'GET'])
def subcategory():
    #Based on the previously selected parent category,display all sub categories
    category = request.form.get('category')
    connection = sql.connect('database.db')
    items = connection.execute('SELECT category_name FROM Categories WHERE parent_category=?;',
                                       (category,)).fetchall()
    subcategories = [item[0] for item in items]
    return render_template('subcategory.html', subcategories=subcategories)

# Displays individual items that can be bidded on
@app.route('/listing', methods=['POST', 'GET'])
def listing():
    connection = sql.connect('database.db')
    subcat = request.form.get('subcategory')
    items = connection.execute('SELECT * FROM Auction_Listings WHERE Category=?;', (subcat,)).fetchall()
    return render_template('listing.html', items=items)

# Displays relevent bidding information for the chosen listing, logic for placing bids.
@app.route('/bid', methods=['POST', 'GET'])
def bid():
    #list id, used to pull bidding information
    lid = request.form.get('lid')
    connection = sql.connect('database.db')
    bidData = connection.execute('SELECT * FROM Bids WHERE Listing_ID=?;', (lid,)).fetchall()
    itemData = connection.execute('SELECT * FROM Auction_Listings WHERE Listing_ID=?;', (lid,)).fetchone()
    return render_template('bid.html', bidData=bidData, itemData=itemData)

if __name__ == "__main__":
    app.run()


